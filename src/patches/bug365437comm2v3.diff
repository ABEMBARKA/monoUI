Index: atk/Util.custom
===================================================================
--- atk/Util.custom	(revision 102022)
+++ atk/Util.custom	(working copy)
@@ -23,6 +23,35 @@
 
 
 		[GLib.CDeclCallback]
+		delegate uint AddGlobalEventListenerNativeDelegate (GLib.Signal.EmissionHookNative hook, IntPtr event_type);
+                
+		static AddGlobalEventListenerDelegate add_global_event_listener_handler;
+		static AddGlobalEventListenerNativeDelegate add_global_event_listener_callback;
+
+		static uint AddGlobalEventListenerCallback (GLib.Signal.EmissionHookNative hook, IntPtr event_type)
+		{
+			try {
+				return add_global_event_listener_handler (new GLib.Signal.EmissionHookMarshaler (hook, IntPtr.Zero).Invoker, GLib.Marshaller.Utf8PtrToString (event_type));
+			} catch (Exception e) {
+				GLib.ExceptionManager.RaiseUnhandledException (e, false);
+			}
+			return 0;
+		}
+
+		public delegate uint AddGlobalEventListenerDelegate (GLib.Signal.EmissionHook hook, string event_type);
+
+		[DllImport("atksharpglue-2")]
+		static extern void atksharp_util_override_add_global_event_listener (AddGlobalEventListenerNativeDelegate cb);
+		public static AddGlobalEventListenerDelegate AddGlobalEventListenerHandler {
+			set {
+				add_global_event_listener_handler = value;
+				if (add_global_event_listener_callback == null)
+					add_global_event_listener_callback = new AddGlobalEventListenerNativeDelegate (AddGlobalEventListenerCallback);
+				atksharp_util_override_add_global_event_listener (add_global_event_listener_callback);
+			}
+		}
+
+		[GLib.CDeclCallback]
 		delegate void RemoveListenerNativeDelegate (uint listener_id);
                 
 		static RemoveListenerDelegate remove_global_event_listener_handler;
Index: atk/Makefile.am
===================================================================
--- atk/Makefile.am	(revision 102022)
+++ atk/Makefile.am	(working copy)
@@ -8,6 +8,7 @@
 sources = 
 
 customs =			\
+	Global.custom		\
 	Misc.custom		\
 	Object.custom		\
 	Util.custom
Index: atk/Atk.metadata
===================================================================
--- atk/Atk.metadata	(revision 102022)
+++ atk/Atk.metadata	(working copy)
@@ -1,5 +1,6 @@
 <?xml version="1.0"?>
 <metadata>
+  <attr path="/api/namespace/class[@cname='AtkGlobal']/method[@name='AddGlobalEventListener']" name="hidden">1</attr>
   <attr path="/api/namespace/class[@cname='AtkState_']" name="name">StateManager</attr>
   <attr path="/api/namespace/interface[@cname='AtkComponent']/*[@name='RefAccessibleAtPoint']/return-type" name="owned">true</attr>
   <attr path="/api/namespace/interface[@cname='AtkDocument']/method[@name='GetAttributes']/return-type" name="element_type">AtkAttribute*</attr>
Index: glib/Signal.cs
===================================================================
--- glib/Signal.cs	(revision 102022)
+++ glib/Signal.cs	(working copy)
@@ -31,26 +31,96 @@
 		Swapped = 1 << 1,
 	}
 
-	[Flags]
-	internal enum SignalFlags {
-		RunFirst = 1 << 0,
-		RunLast = 1 << 1,
-		RunCleanup = 1 << 2,
-		NoRecurse = 1 << 3,
-		Detailed = 1 << 4,
-		Action = 1 << 5,
-		NoHooks = 1 << 6
-	}
+	public class Signal {
 
-	[StructLayout (LayoutKind.Sequential)]
-	internal struct InvocationHint {
-		public uint signal_id;
-		public uint detail;
-		public SignalFlags run_type;
-	}
+		[Flags]
+		public enum Flags {
+			RunFirst = 1 << 0,
+			RunLast = 1 << 1,
+			RunCleanup = 1 << 2,
+			NoRecurse = 1 << 3,
+			Detailed = 1 << 4,
+			Action = 1 << 5,
+			NoHooks = 1 << 6
+		}
 
-	public class Signal {
+		[StructLayout (LayoutKind.Sequential)]
+		public struct InvocationHint {
+			public uint signal_id;
+			public uint detail;
+			public Flags run_type;
+		}
 
+		[CDeclCallback]
+		public delegate bool EmissionHookNative (ref InvocationHint hint, uint n_pvals, IntPtr pvals, IntPtr data);
+
+		public delegate bool EmissionHook (InvocationHint ihint, object[] inst_and_param_values);
+
+		public class EmissionHookMarshaler {
+
+			EmissionHook handler;
+			EmissionHookNative cb;
+			IntPtr user_data;
+			GCHandle gch;
+
+			public EmissionHookMarshaler (EmissionHook handler)
+			{
+				this.handler = handler;
+				cb = new EmissionHookNative (NativeCallback);
+				gch = GCHandle.Alloc (this);
+			}
+
+			public EmissionHookMarshaler (EmissionHookNative callback, IntPtr user_data)
+			{
+				cb = callback;
+				this.user_data = user_data;
+				handler = new EmissionHook (NativeInvoker);
+			}
+
+			bool NativeCallback (ref InvocationHint hint, uint n_pvals, IntPtr pvals_ptr, IntPtr data)
+			{
+				object[] pvals = new object [n_pvals];
+				for (int i = 0; i < n_pvals; i++) {
+					IntPtr p = new IntPtr ((long) pvals_ptr + i * Marshal.SizeOf (typeof (Value)));
+					Value v = (Value) Marshal.PtrToStructure (p, typeof (Value));
+					pvals [i] = v.Val;
+				}
+				bool result = handler (hint, pvals);
+				if (!result)
+					gch.Free ();
+				return result;
+			}
+
+			public EmissionHookNative Callback {
+				get {
+					return cb;
+				}
+			}
+
+			bool NativeInvoker (InvocationHint ihint, object[] pvals)
+			{
+				int val_sz = Marshal.SizeOf (typeof (Value));
+				IntPtr buf = Marshal.AllocHGlobal (pvals.Length * val_sz);
+				Value[] vals = new Value [pvals.Length];
+				for (int i = 0; i < pvals.Length; i++) {
+					vals [i] = new Value (pvals [i]);
+					IntPtr p = new IntPtr ((long) buf + i * val_sz);
+					Marshal.StructureToPtr (vals [i], p, false);
+				}
+				bool result = cb (ref ihint, (uint) pvals.Length, buf, user_data);
+				foreach (Value v in vals)
+					v.Dispose ();
+				Marshal.FreeHGlobal (buf);
+				return result;	
+			}
+
+			public EmissionHook Invoker {
+				get {
+					return handler;
+				}
+			}
+		}
+
 		GCHandle gc_handle;
 		ToggleRef tref;
 		string name;
@@ -100,7 +170,7 @@
 		public Delegate Handler {
 			get {
 				InvocationHint hint = (InvocationHint) Marshal.PtrToStructure (g_signal_get_invocation_hint (tref.Handle), typeof (InvocationHint));
-				if (hint.run_type == SignalFlags.RunFirst)
+				if (hint.run_type == Flags.RunFirst)
 					return before_handler;
 				else
 					return after_handler;
@@ -224,15 +294,36 @@
 			return ret;
 		}
 
+		private static uint GetSignalId (string signal_name, GLib.GType type)
+ 		{
+			Console.WriteLine ("type to search: " + type.ToString ());
+			return GetSignalId (signal_name, type.Val);
+		}
+		
 		private static uint GetSignalId (string signal_name, GLib.Object obj)
 		{
-			IntPtr typeid = gtksharp_get_type_id (obj.Handle);
-			IntPtr native_name = GLib.Marshaller.StringToPtrGStrdup (signal_name);
-			uint signal_id = g_signal_lookup (native_name, typeid);
-			GLib.Marshaller.Free (native_name);
-			return signal_id;
+ 			IntPtr typeid = gtksharp_get_type_id (obj.Handle);
+			return GetSignalId (signal_name, typeid);
 		}
 		
+		private static uint GetSignalId (string signal_name, IntPtr typeid)
+		{
+ 			IntPtr native_name = GLib.Marshaller.StringToPtrGStrdup (signal_name);
+ 			uint signal_id = g_signal_lookup (native_name, typeid);
+ 			GLib.Marshaller.Free (native_name);
+ 			return signal_id;
+ 		}
+		public static ulong AddEmissionHandler (string signal_name, GLib.GType type, EmissionHook handler_func, IntPtr data)
+		{
+			return AddEmissionHandler (signal_name, 0, type, handler_func, data);
+		}
+		
+		public static ulong AddEmissionHandler (string signal_name, uint signal_detail, GLib.GType type, EmissionHook handler_func, IntPtr data)
+		{
+			uint signal_id = GetSignalId (signal_name, type);
+			return g_signal_add_emission_hook (signal_id, signal_detail, new EmissionHookMarshaler (handler_func).Callback, data, IntPtr.Zero);
+		}
+
 		[DllImport("libgobject-2.0-0.dll")]
 		static extern uint g_signal_connect_data(IntPtr obj, IntPtr name, Delegate cb, IntPtr gc_handle, IntPtr dummy, int flags);
 
@@ -257,6 +348,10 @@
 		
 		[DllImport("glibsharpglue-2")]
 		static extern IntPtr gtksharp_get_type_id (IntPtr raw);
+
+		[DllImport("libgobject-2.0-0.dll")]
+		static extern ulong g_signal_add_emission_hook (uint signal_id, uint gquark_detail, EmissionHookNative hook_func, IntPtr hook_data, IntPtr data_destroy);
+
 	}
 }
 
Index: glib/GType.cs
===================================================================
--- glib/GType.cs	(revision 102022)
+++ glib/GType.cs	(working copy)
@@ -36,6 +36,10 @@
 		{
 			this.val = val;
 		}
+		
+		public GType (string native_name) : this (g_type_from_name (native_name))
+		{
+		}
 
 		public static readonly GType Invalid = new GType ((IntPtr) TypeFundamentals.TypeInvalid);
 		public static readonly GType None = new GType ((IntPtr) TypeFundamentals.TypeNone);
@@ -197,5 +201,8 @@
 		{
 			return Marshaller.Utf8PtrToString (g_type_name (val));
 		}
+		
+		[DllImport("libgobject-2.0-0.dll")]
+		static extern IntPtr g_type_from_name (string name);
 	}
 }
Index: glib/ObjectManager.cs
===================================================================
--- glib/ObjectManager.cs	(revision 102022)
+++ glib/ObjectManager.cs	(working copy)
@@ -58,7 +58,7 @@
 		[Obsolete ("Replaced by GType.Register (GType, Type)")]
 		public static void RegisterType (string native_name, string mangled)
 		{
-			RegisterType (new GType (g_type_from_name (native_name)), Type.GetType (mangled));
+			RegisterType (new GType (native_name), Type.GetType (mangled));
 		}
 
 		[Obsolete ("Replaced by GType.Register (GType, Type)")]
@@ -86,8 +86,5 @@
 
 		[DllImport("libgobject-2.0-0.dll")]
 		static extern IntPtr g_type_parent (IntPtr typ);
-
-		[DllImport("libgobject-2.0-0.dll")]
-		static extern IntPtr g_type_from_name (string name);
 	}
 }
