Index: atk/Object.custom
===================================================================
--- atk/Object.custom	(revision 101455)
+++ atk/Object.custom	(working copy)
@@ -92,3 +92,27 @@
 			return null;
 		}
 
+		protected void EmitChildrenChanged (ChildrenChangedDetail detail, 
+											int childNumber, Atk.Object child)
+		{
+			string detailed_signal = detail.ToString().ToLower();
+			
+			GLib.Signal childrenChangedSignal = GLib.Signal.Lookup (child, "children-changed");
+			
+			GLib.Value[] args = new GLib.Value[2];
+			GLib.Value atkobjValue = new GLib.Value(this);
+			args [0] = new GLib.Value (childNumber);
+			args [1] = new GLib.Value (child);
+			
+			childrenChangedSignal.EmitVSharp (atkobjValue, detailed_signal, args);
+			atkobjValue.Dispose ();
+			args [0].Dispose ();
+			args [1].Dispose ();
+		}
+		
+		protected enum ChildrenChangedDetail
+		{
+			Add,
+			Remove
+		}
+		
\ No newline at end of file
Index: atk/Util.custom
===================================================================
--- atk/Util.custom	(revision 101455)
+++ atk/Util.custom	(working copy)
@@ -21,10 +21,42 @@
 // Free Software Foundation, Inc., 59 Temple Place - Suite 330,
 // Boston, MA 02111-1307, USA.
 
+		[GLib.CDeclCallback]
+		delegate int AddGlobalListenerNativeDelegate (IntPtr listener, string event_type);
 
+		static AddGlobalListenerDelegate add_global_event_listener_handler;
+		static AddGlobalListenerNativeDelegate add_global_event_listener_callback;
+
+		static int AddGlobalEventListenerCallback (IntPtr listener, string event_type)
+		{
+			try {
+				return add_global_event_listener_handler (listener, event_type);
+			} catch (Exception e) {
+				GLib.ExceptionManager.RaiseUnhandledException (e, false);
+			}
+			
+			return 0;
+		}
+
+		[DllImport("atksharpglue-2")]
+		static extern void atksharp_util_override_add_global_event_listener (AddGlobalListenerNativeDelegate cb);
+		
+		public delegate int AddGlobalListenerDelegate (IntPtr listener, string event_type);
+
+		public static AddGlobalListenerDelegate AddGlobalEventListenerHandler {
+			set {
+				add_global_event_listener_handler = value;
+				if (add_global_event_listener_callback == null)
+					add_global_event_listener_callback = new AddGlobalListenerNativeDelegate (AddGlobalEventListenerCallback);
+				atksharp_util_override_add_global_event_listener (add_global_event_listener_callback);
+			}
+		}
+
+
+
 		[GLib.CDeclCallback]
 		delegate void RemoveListenerNativeDelegate (uint listener_id);
-                
+
 		static RemoveListenerDelegate remove_global_event_listener_handler;
 		static RemoveListenerNativeDelegate remove_global_event_listener_callback;
 
@@ -40,6 +72,7 @@
 		[DllImport("atksharpglue-2")]
 		static extern void atksharp_util_override_remove_global_event_listener (RemoveListenerNativeDelegate cb);
 		
+		//shared by RemoveGlobalEventListener and RemoveKeyEventListener
 		public delegate void RemoveListenerDelegate (uint listener_id);
 
 		public static RemoveListenerDelegate RemoveGlobalEventListenerHandler {
@@ -80,7 +113,7 @@
 
 		[GLib.CDeclCallback]
 		delegate uint AddKeyEventListenerNativeDelegate (AtkSharp.KeySnoopFuncNative native_func, IntPtr data);
-                
+
 		static AddKeyEventListenerDelegate add_key_event_listener_handler;
 		static AddKeyEventListenerNativeDelegate add_key_event_listener_callback;
 
@@ -134,7 +167,7 @@
 
 		[GLib.CDeclCallback]
 		delegate IntPtr GetRootNativeDelegate ();
-                
+
 		static GetRootDelegate get_root_handler;
 		static GetRootNativeDelegate get_root_callback;
 
@@ -161,10 +194,10 @@
 				atksharp_util_override_get_root (get_root_callback);
 			}
 		}
-               
+
 		[GLib.CDeclCallback]
 		delegate IntPtr GetToolkitNameNativeDelegate ();
-                
+
 		static GetToolkitNameDelegate get_toolkit_name_handler;
 		static GetToolkitNameNativeDelegate get_toolkit_name_callback;
 		static string toolkit_name;
@@ -199,10 +232,10 @@
 				atksharp_util_override_get_toolkit_name (get_toolkit_name_callback);
 			}
 		}
-               
+
 		[GLib.CDeclCallback]
 		delegate IntPtr GetToolkitVersionNativeDelegate ();
-                
+
 		static GetToolkitVersionDelegate get_toolkit_version_handler;
 		static GetToolkitVersionNativeDelegate get_toolkit_version_callback;
 		static string toolkit_version;
@@ -237,4 +270,3 @@
 				atksharp_util_override_get_toolkit_version (get_toolkit_version_callback);
 			}
 		}
-               
Index: atk/glue/util.c
===================================================================
--- atk/glue/util.c	(revision 101455)
+++ atk/glue/util.c	(working copy)
@@ -29,14 +29,15 @@
 void atksharp_util_override_get_toolkit_name (gpointer cb);
 void atksharp_util_override_get_toolkit_version (gpointer cb);
 
-void
-atksharp_util_override_add_global_event_listener (gpointer cb)
-{
-	AtkUtilClass *klass = g_type_class_peek (ATK_TYPE_UTIL);
-	if (!klass)
-		klass = g_type_class_ref (ATK_TYPE_UTIL);
-	((AtkUtilClass *) klass)->add_global_event_listener = cb;
-}
+//	disabled until we can get rid of the workaround:
+//void
+//atksharp_util_override_add_global_event_listener (gpointer cb)
+//{
+//	AtkUtilClass *klass = g_type_class_peek (ATK_TYPE_UTIL);
+//	if (!klass)
+//		klass = g_type_class_ref (ATK_TYPE_UTIL);
+//	((AtkUtilClass *) klass)->add_global_event_listener = cb;
+//}
 
 void
 atksharp_util_override_remove_global_event_listener (gpointer cb)
@@ -92,3 +93,111 @@
 	((AtkUtilClass *) klass)->get_toolkit_version = cb;
 }
 
+
+//workaround:
+
+static GHashTable *listener_list = NULL;
+
+guint atksharp_util_add_global_event_listener(
+	GSignalEmissionHook listener,
+	const gchar *event_type);
+
+static void
+_listener_info_destroy (gpointer data)
+{
+	g_free(data);
+}
+
+void
+atksharp_util_override_add_global_event_listener (gpointer cb)
+{
+	AtkUtilClass *klass = g_type_class_peek (ATK_TYPE_UTIL);
+	if (!klass)
+		klass = g_type_class_ref (ATK_TYPE_UTIL);
+	//disabled until we can get rid of the workaround:
+	//((AtkUtilClass *) klass)->add_global_event_listener = cb;
+	((AtkUtilClass *) klass)->add_global_event_listener = atksharp_util_add_global_event_listener;
+	
+	listener_list = g_hash_table_new_full(g_int_hash, g_int_equal, NULL, _listener_info_destroy);
+}
+
+
+static gint listener_idx = 1;
+
+typedef struct _AtkUtilListenerInfo AtkUtilListenerInfo;
+
+struct _AtkUtilListenerInfo
+{
+   gint key;
+   guint signal_id;
+   gulong hook_id;
+};
+
+
+guint
+_atksharp_add_listener (GSignalEmissionHook listener,
+              const gchar         *object_type,
+              const gchar         *signal,
+              const gchar         *hook_data)
+{
+  GType type;
+  guint signal_id;
+  gint  rc = 0;
+
+  type = g_type_from_name (object_type);
+  if (type)
+    {
+      signal_id  = g_signal_lookup (signal, type);
+      if (signal_id > 0)
+        {
+          AtkUtilListenerInfo *listener_info;
+
+          rc = listener_idx;
+
+          listener_info = g_malloc(sizeof(AtkUtilListenerInfo));
+          listener_info->key = listener_idx;
+          listener_info->hook_id =
+                          g_signal_add_emission_hook (signal_id, 0, listener,
+			        		      g_strdup (hook_data),
+			        		      (GDestroyNotify) g_free);
+          listener_info->signal_id = signal_id;
+
+	  g_hash_table_insert(listener_list, &(listener_info->key), listener_info);
+          listener_idx++;
+        }
+      else
+        {
+          g_warning("Invalid signal type %s\n", signal);
+        }
+    }
+  else
+    {
+      g_warning("Invalid object type %s\n", object_type);
+    }
+  return rc;
+}
+
+guint atksharp_util_add_global_event_listener(
+	GSignalEmissionHook listener,
+	const gchar *event_type)
+{
+	guint rc = 0;
+	gchar **split_string;
+
+	//split_string[0]: toolkit
+	//            [1]: class/interface
+	//            [2]: event type
+	// example: Gtk:AtkObject:children-changed
+	split_string = g_strsplit (event_type, ":", 3);
+
+	g_warning(g_strdup_printf("add global event listener, event_type: %s", event_type));
+
+	if (split_string)
+	{
+		rc = _atksharp_add_listener (listener, split_string[1], split_string[2], event_type);
+
+		g_strfreev (split_string);
+	}
+
+	return rc;
+}
Index: glib/GQuark.cs
===================================================================
--- glib/GQuark.cs	(revision 0)
+++ glib/GQuark.cs	(revision 0)
@@ -0,0 +1,39 @@
+// GLib.GQuark.cs : Class for managed GQuark
+//
+// Author: Andres G. Aragoneses  <aaragoneses@novell.com>
+//
+// Copyright (c) 2008 Novell, Inc.
+//
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of version 2 of the Lesser GNU General 
+// Public License as published by the Free Software Foundation.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Lesser General Public License for more details.
+//
+// You should have received a copy of the GNU Lesser General Public
+// License along with this program; if not, write to the
+// Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+// Boston, MA 02111-1307, USA.
+
+
+namespace GLib {
+	using System;
+	using System.Runtime.InteropServices;
+	
+	public class GQuark {
+		
+		//static class
+		private GQuark () { }
+		
+		//better not to expose FromStaticString () due to memory allocation issues
+		public static uint FromString (string str) {
+			return g_quark_from_string (str);
+		}
+		
+		[DllImport("libglib-2.0-0.dll")]
+		static extern uint g_quark_from_string (string str);
+	}
+}
Index: glib/Signal.cs
===================================================================
--- glib/Signal.cs	(revision 101455)
+++ glib/Signal.cs	(working copy)
@@ -1,6 +1,7 @@
 // GLib.Signal.cs - signal marshaling class
 //
 // Authors: Mike Kestner <mkestner@novell.com>
+//          Andres G. Aragoneses <aaragoneses@novell.com>
 //
 // Copyright (c) 2005 Novell, Inc.
 //
@@ -57,6 +58,7 @@
 		uint before_id = UInt32.MaxValue;
 		uint after_id = UInt32.MaxValue;
 		Delegate marshaler;
+		uint signal_id;
 
 		~Signal ()
 		{
@@ -70,6 +72,10 @@
 			this.marshaler = marshaler;
 			gc_handle = GCHandle.Alloc (this, GCHandleType.Weak);
 			tref.Signals [name] = this;
+			
+			//TODO: don't know how to call this, none of these work:
+			signal_id = g_signal_lookup (signal_name, obj.GType.Handle);
+			signal_id = g_signal_lookup (signal_name, GLib.Object.LookupGType(obj.GetType()).val);
 		}
 
 		internal void Free ()
@@ -190,7 +196,33 @@
 				return event_handler_delegate;
 			}
 		}
+		
+		public GLib.Value EmitVSharp (GLib.Value instance, string gquark_detail, params GLib.Value[] args)
+		{
+			uint gquark = GLib.GQuark.FromString (gquark_detail);
+			
+			GLib.Value ret;
+			uint numberOfParams = (uint)(args.Length + 1);
+			
+			GLib.ValueArray inst_and_params = new GLib.ValueArray (numberOfParams);
+			inst_and_params.Append (instance);
+			
+			for (int i = 0; i < args.Length; i++)
+			{
+				inst_and_params.Append (args [i]);
+			}
 
+			EmitV (inst_and_params, signal_id, gquark, out ret);
+			
+			return ret;
+		}
+
+		private static void EmitV (GLib.ValueArray instance_and_params, uint signal_id, uint gquark_detail, out GLib.Value return_value)
+		{
+			return_value = GLib.Value.Empty;
+			g_signal_emitv (instance_and_params.ArrayPtr, signal_id, gquark_detail, ref return_value);
+		}
+		
 		[DllImport("libgobject-2.0-0.dll")]
 		static extern uint g_signal_connect_data(IntPtr obj, IntPtr name, Delegate cb, IntPtr gc_handle, IntPtr dummy, int flags);
 
@@ -202,6 +234,12 @@
 
 		[DllImport("libgobject-2.0-0.dll")]
 		static extern bool g_signal_handler_is_connected (IntPtr instance, uint handler);
+		
+		[DllImport("libgobject-2.0-0.dll")]
+		static extern void g_signal_emitv (IntPtr instance_and_params, uint signal_id, uint gquark_detail, ref GLib.Value return_value);
+
+		[DllImport("libgobject-2.0-0.dll")]
+		static extern uint g_signal_lookup (string name, IntPtr itype);
 	}
 }
 
Index: glib/Makefile.am
===================================================================
--- glib/Makefile.am	(revision 101455)
+++ glib/Makefile.am	(working copy)
@@ -33,6 +33,7 @@
 	GInterfaceAdapter.cs			\
 	GInterfaceAttribute.cs			\
 	Global.cs				\
+	GQuark.cs				\
 	GString.cs				\
 	GType.cs				\
 	GTypeAttribute.cs			\
