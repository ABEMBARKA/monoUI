<#
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//
// Copyright (c) 2009 Novell, Inc. (http://www.novell.com)
//
// Authors:
//      Brad Taylor <brad@getcoded.net>
//
#>
<#@ template language="C#v3.5" #>
<#@ import namespace="System" #>
<#@ import namespace="Mono.Cecil" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Reflection" #>
<#@ import namespace="System.Collections" #>
<#@ import namespace="System.Collections.Generic" #>
// This file was generated by the Moonlight.AtkBridge code generator.
// Any changes made will be lost if regenerated.

using Atk;
using System.Windows;
using Moonlight.AtkBridge;
using System.Windows.Automation;
using System.Windows.Automation.Peers;
using Moonlight.AtkBridge.PatternImplementors;

namespace Moonlight.AtkBridge.Adapters
{
<#

List<HashSet<string>> implementors
	= new List<HashSet<string>> ();
Dictionary<string, TypeDefinition> typeDefinitions
	= new Dictionary<string, TypeDefinition> ();
Dictionary<string, List<CustomAttribute>> implementsPatternAttrs
	= new Dictionary<string, List<CustomAttribute>> ();

AssemblyDefinition asm
	= AssemblyFactory.GetAssembly ("bin/raw/MoonAtkBridge.dll");
((BaseAssemblyResolver) asm.Resolver).AddSearchDirectory ("bin/raw");

// Scan all the types in the module looking for ones that have the
// [ImplementsPattern (...)] attribute.
foreach (ModuleDefinition module in asm.Modules) {
	foreach (TypeDefinition type in module.Types) {
		List<CustomAttribute> attrs = new List<CustomAttribute> ();
		foreach (CustomAttribute attr in type.CustomAttributes) {
			attr.Resolve ();
			if (attr.Constructor.DeclaringType.Name == "ImplementsPatternAttribute")
				attrs.Add (attr);
		}

		if (attrs.Count < 1)
			continue;

		typeDefinitions[type.Name] = type;
		implementsPatternAttrs[type.Name] = attrs;
		implementors.Add (new HashSet<string> (
			new string[] { type.Name }
		));
	}
}

// Create a list of implementor combinations
List<HashSet<string>> combinations
	= new List<HashSet<string>> (implementors);
for (int i = 0; i < implementors.Count; i++)
	combinations = Combine (implementors, combinations);

// Create a class for every combination of implementor
foreach (HashSet<string> impls in combinations) {
	string typeName = String.Join ("", impls.OrderBy (x => x).ToArray ()) + "Adapter";

	HashSet<CustomAttribute> attrs = new HashSet<CustomAttribute> (
		new CustomAttributeEqualityComparer ()
	);
	HashSet<string> ifaces = new HashSet<string> ();

	// Add our base adapter class
	ifaces.Add ("Adapter");

	// Detect if we are trying to implement the same interface twice.  If
	// this is the case, this combination of pattern implementors will
	// never work.
	bool duplicate_iface = false;

	// Collect all the interfaces and attributes that we need for our
	// adapter
	foreach (string impl in impls) {
		TypeDefinition type;
		if (!typeDefinitions.TryGetValue (impl, out type))
			continue;

		List<CustomAttribute> implAttrs;
		if (implementsPatternAttrs.TryGetValue (
		    impl, out implAttrs)) {
			foreach (CustomAttribute attr in implAttrs)
				attrs.Add (attr);
		}

		foreach (TypeDefinition i in GetAllInterfaces (type)) {
			if (i.Namespace != "Atk")
				continue;

			if (ifaces.Contains (i.FullName)) {
				duplicate_iface = true;
				break;
			}

			ifaces.Add (i.FullName);
		}

		if (duplicate_iface)
			break;
	}

	if (duplicate_iface)
		continue;

	foreach (CustomAttribute attr in attrs) {
		if (attr.ConstructorParameters.Count < 1)
			continue;

		List<string> parameter_list = new List<string> ();
		for (int i = 0; i < attr.ConstructorParameters.Count; i++) {
			ParameterReference p = attr.Constructor.Parameters [i];
			object val = attr.ConstructorParameters [i];

			parameter_list.Add (String.Format ("({0}) {1}",
			                                   p.ParameterType.FullName,
			                                   val));
		}
#>
	[<#= attr.Constructor.DeclaringType.FullName #> (<#= String.Join (", ", parameter_list.ToArray ()) #>)]
<#
	}
#>
	public class <#= typeName #> : <#= String.Join (", ", ifaces.ToArray ()) #>
	{
		public <#= typeName #> (AutomationPeer peer) : base (peer)
		{
<#
	// Initialize implementor fields
	foreach (string impl in impls) {
		TypeDefinition type;
		if (!typeDefinitions.TryGetValue (impl, out type))
			continue;
#>
			<#= ToFieldName (impl) #> = new <#= type.FullName #> (this, peer);
<# 	} #>

			implementors = new BasePatternImplementor[] {
<# 	foreach (string impl in impls) { #>
				<#= ToFieldName (impl) #>,
<# 	} #>
			};
		}

		protected override BasePatternImplementor[] PatternImplementors {
			get { return implementors; }
		}
<#
	// Wrap all the methods and properties in the implementor
	foreach (string impl in impls) {
		TypeDefinition type;
		if (!typeDefinitions.TryGetValue (impl, out type))
			continue;
#>

#region <#= impl #> implementation
<#
		// Create wrappers for all the methods described by
		// this PatternImplementor

		// LAME: We have to manually chain up the hierarchy, because
		// Cecil won't do this for us.
		foreach (MethodDefinition meth in GetAllMethods (type)) {
			if (!meth.IsPublic)
				continue;

			if (meth.IsSetter || meth.IsGetter)
				continue;

			TypeDefinition iface = GetImplementingInterface (type, meth);
			if (iface == null)
				continue;

#>
		<#= meth.ReturnType.ReturnType.FullName #> <#= iface.FullName #>.<#= meth.Name #> (<#= BuildParamList (meth.Parameters, true) #>)
		{
<#
			string ret = "return ";
			if (meth.ReturnType.ReturnType.Name == "Void")
				ret = "";
#>
			<#= ret #><#= ToFieldName (impl) #>.<#= meth.Name #> (<#= BuildParamList (meth.Parameters, false) #>);
		}

<# 		} #>
<#
		// LAME: We have to manually chain up the hierarchy, because
		// Cecil won't do this for us.
		foreach (PropertyDefinition prop in GetAllProperties (type)) {
			MethodDefinition getMethod = prop.GetMethod;
			MethodDefinition setMethod = prop.SetMethod;

			if ((getMethod != null && !getMethod.IsPublic)
			    || (setMethod != null && !setMethod.IsPublic))
				continue;

			TypeDefinition iface = GetImplementingInterface (type, getMethod ?? setMethod);
			if (iface == null)
				continue;

#>
		<#= prop.PropertyType.FullName #> <#= iface.FullName #>.<#= prop.Name #> {
<#
			if (getMethod != null) {
#>
			get { return <#= ToFieldName (impl) #>.<#= prop.Name #>; }
<#
			}

			if (setMethod != null) {
#>
			set { <#= ToFieldName (impl) #>.<#= prop.Name #> = value; }
<#
			}
#>
		}

<# 		} #>
#pragma warning disable 0414
		private <#= type.FullName #> <#= ToFieldName (impl) #>;
#pragma warning restore 0414
#endregion
<# 	} #>

#pragma warning disable 0414
		private BasePatternImplementor[] implementors;
#pragma warning restore 0414
	}

<# } #>
}
<#+
	/*
	 * Returns a List containing all unique combinations of the two lists,
	 * irrespective of pairwise order.
	 */
	public static List<HashSet<string>> Combine (List<HashSet<string>> a,
	                                             List<HashSet<string>> b)
	{
		HashSetEqualityComparer<string> comparer
			= new HashSetEqualityComparer<string> ();

		List<HashSet<string>> items = new List<HashSet<string>> ();
		foreach (HashSet<string> i in a) {
			foreach (HashSet<string> j in b) {
				HashSet<string> item = new HashSet<string> (i);
				item.UnionWith (j);
				item.RemoveWhere (x => x == "");

				if (!items.Contains (item, comparer))
					items.Add (item);
			}
		}
		return items;
	}

	/*
	 * Compares the elements inside of the HashSet to determine equality.
	 * This differs from HashSet's default .Equals, which is merely a
	 * ReferenceEquals.
	 */
	public class HashSetEqualityComparer<T> : IEqualityComparer<HashSet<T>>
	{
		public bool Equals (HashSet<T> a, HashSet<T> b)
		{
			if (Object.ReferenceEquals (a, b))
				return true;

			if (Object.ReferenceEquals (a, null)
			    || Object.ReferenceEquals (b, null))
				return false;

			if (a.Count != b.Count)
				return false;

			foreach (T item in a)
				if (!b.Contains (item))
					return false;

			return true;
		}

		public int GetHashCode (HashSet<T> set)
		{
			int hash = 0;
			foreach (T i in set)
				hash ^= i.GetHashCode ();

			return hash;
		}
	}

	public string ToFieldName (string typeName)
	{
		return String.Format ("{0}Field", typeName.ToLower ());
	}

	public string BuildParamList (ParameterDefinitionCollection paras, bool withTypes)
	{
		List<string> paramList = new List<string> ();
		foreach (ParameterDefinition param in paras)
		{
			string paramDef = "";
			if (param.IsIn) {
				paramDef += "in ";
			} else if (param.IsOut) {
				paramDef += "out ";
			} else if (param.ParameterType.FullName.Contains ("&")) {
				paramDef += "ref ";
			}

			if (withTypes)
				paramDef += param.ParameterType.FullName.Replace ("&", "") + " ";

			paramList.Add (paramDef + String.Format ("param{0}", paramList.Count));
		}
		return String.Join (", ", paramList.ToArray ());
	}

	public class CustomAttributeEqualityComparer : IEqualityComparer<CustomAttribute>
	{
		public bool Equals (CustomAttribute a, CustomAttribute b)
		{
			if (Object.ReferenceEquals (a, b))
				return true;

			if (Object.ReferenceEquals (a, null)
			    || Object.ReferenceEquals (b, null))
				return false;

			if (a.Constructor.DeclaringType.FullName
			    != b.Constructor.DeclaringType.FullName)
				return false;

			if (a.ConstructorParameters.Count
			    != b.ConstructorParameters.Count)
				return false;

			for (int i = 0; i < a.ConstructorParameters.Count; i++) {
				if (a.ConstructorParameters[i]
				    != b.ConstructorParameters[i])
					return false;
			}

			return true;
		}

		public int GetHashCode (CustomAttribute attr)
		{
			int hash = attr.Constructor.DeclaringType.Name.GetHashCode ();
			foreach (object o in attr.ConstructorParameters)
				hash ^= o.GetHashCode ();
			return hash;
		}
	}

	// Find out which interface this method belongs to.
	public TypeDefinition GetImplementingInterface (TypeDefinition type, MethodDefinition meth)
	{
		// XXX: This is going to be very inefficient
		TypeDefinition iface = null;
		foreach (TypeDefinition i in type.Interfaces) {
			foreach (MethodDefinition m in i.Methods) {
				if (m.Name == meth.Name) {
					iface = i;
					break;
				}
			}

			if (iface != null)
				break;
		}

		return iface;
	}

	public static TypeReference[] GetAllInterfaces (TypeDefinition type)
	{
		return GetAll<TypeReference> (type, t => t.Interfaces);
	}

	public static MethodReference[] GetAllMethods (TypeDefinition type)
	{
		return GetAll<MethodReference> (type, t => t.Methods);
	}

	public static PropertyReference[] GetAllProperties (TypeDefinition type)
	{
		return GetAll<PropertyReference> (type, t => t.Properties);
	}

	private static T[] GetAll<T> (TypeDefinition type, Func<TypeDefinition, IEnumerable> get_method)
	{
		List<T> items = new List<T> ();

		TypeDefinition iter = type;
		while (iter != null) {
			foreach (T item in get_method (iter))
				items.Add (item);
			iter = iter.BaseType != null ? iter.BaseType.Resolve ()
			                             : null;
		}

		return items.ToArray ();
	}
#>
