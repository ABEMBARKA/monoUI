#!/usr/bin/env python

# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# Copyright (c) 2010 Novell, Inc. (http://www.novell.com)
#
# Authors:
#      Mario Carrion <mcarrion@novell.com>
#

from moonlight import *
from strongwind import *

from os.path import abspath
import pyatspi

class DataGridItem(TestCase):
    """
    Exercises DataGridItem control. DataGridItem control implements:
    - UIA.Invoke pattern, mapped to Action.
    - UIA.ScrollItem pattern, NOT mapped.
    - UIA.SelectionItem pattern, mapped to Parent's Selection,
      however this *does not work* because our parent is not the DataGrid
      but a container.
    - UIA.Selection pattern, mapped to Selection

    """

    @classmethod
    def setup_class(cls):
        cls.app = launchAddress(abspath('assets/DataGridTest/DataGridTest.html'))

        # Hierarchy is like this:
        # DataGrid
        # - Table Row Header - TableRowHeader
        # - Rows - Unknown
        # -- DataGridItem0 - TableCell
        # -- DataGridItem1 - TableCell
        # -- DataGridItemN - TableCell
        # - HScrollbar - ScrollBar
        # - VScrollbar - ScrollBar

        cls.datagrid = cls.app.slControl.findAllTables('')[0]
        cls.rows_container = cls.app.slControl.findAllUnknowns('')[0]

        cls.add_button = cls.app.slControl.findPushButton('Add Row')

    @classmethod
    def teardown_class(cls):
        cls.app.kill()

    # Basic Tests

    def test_datagriditem_basic(self):
        # Test DataGridItems container
        self.assertEqual('', self.rows_container.name)

        self.assertInterfaces(self.rows_container, [
            'accessible', 'component'
        ])

        self.assertStates(self.rows_container, [
            'enabled', 'sensitive', 'showing', 'visible'
        ])

        # 4 Rows
        self.assertEqual(4, self.rows_container.childCount)

        # Test all DataGridItems
        for i in xrange(0, 3):
            datagridcell = self.rows_container.getChildAtIndex(i)
            self.assertEqual(pyatspi.ROLE_TABLE_CELL, datagridcell.role)
            self.assertEqual('DataGridTest.Data', datagridcell.name)
            # 2 autogenerated tablecells and 3 real cells
            self.assertEqual(5, datagridcell.childCount)

            self.assertInterfaces(datagridcell, [
                'accessible', 'component', 'action', 'selection'
            ])

            if i == 0:
                self.assertStates(datagridcell, [
                    'enabled', 'selected', 'selectable', 'sensitive',
                    'showing', 'visible'
                ])
            else:
                self.assertStates(datagridcell, [
                    'enabled', 'selectable', 'sensitive', 'showing',
                    'visible'
                ])

    # Tests selection children, aka, DataGridCells
    def test_datagridcell_basic(self):
        datagridcell = self.rows_container.getChildAtIndex(1)

        # The item has 5 children:
        # - TableCell
        # - Cell0
        # - Cell1
        # - Cell2
        # - EmtpyCell
        # The first and the last are autogenerated cells,
        # don't represent our ItemsSource.

        roles = [
            pyatspi.ROLE_TABLE_CELL, pyatspi.ROLE_UNKNOWN,
            pyatspi.ROLE_UNKNOWN,    pyatspi.ROLE_UNKNOWN,
            pyatspi.ROLE_UNKNOWN
        ]
        states = [
            [ 'enabled', 'sensitive' ],
            [ 'enabled', 'focusable', 'selectable', 'sensitive', 'showing', 'visible' ],
            [ 'enabled', 'focusable', 'selectable', 'sensitive', 'showing', 'visible' ],
            [ 'enabled', 'focusable', 'selectable', 'sensitive', 'showing', 'visible' ],
            [ 'enabled', 'sensitive', 'showing', 'visible' ]
        ]
        interfaces = [
            [ 'accessible', 'component' ],
            [ 'accessible', 'action', 'component' ],
            [ 'accessible', 'action', 'component' ],
            [ 'accessible', 'component' ],
            [ 'accessible', 'component' ]
        ]
        names = [ '', '', 'Edit1', 'Read1', '' ]
        children = [ 0, 1, 1, 1, 0 ]

        for i in xrange(0, datagridcell.childCount):
            item = datagridcell.getChildAtIndex(i)
            self.assertEqual(roles[i], item.role)
            self.assertEqual(names[i], item.name)
            self.assertEqual(children[i], item.childCount)
            self.assertInterfaces(item, interfaces[i])
            self.assertStates(item, states[i])

    # Selection Tests

    # Tests selection children, aka, DataGridCells
    def test_selection(self):
        datagridcell = self.rows_container.getChildAtIndex(1)
        selection = datagridcell._accessible.querySelection()

        # The item has 5 children:
        # - TableCell
        # - Cell0
        # - Cell1
        # - Cell2
        # - EmtpyCell
        # The first and the last are autogenerated cells,
        # don't represent our ItemsSource. Only the Cells implement SelectionItem
        for x in xrange(1, datagridcell.childCount - 1):
            item = datagridcell.getChildAtIndex(x)

            self.assertFalse(item.selected)
            self.assertFalse(selection.isChildSelected(x))

        # Let's select and unselect
        previous = None
        for x in xrange(1, datagridcell.childCount -1):
            item = datagridcell.getChildAtIndex(x)

            self.assertTrue(selection.selectChild(x))
            self.assertTrue(item.selected)
            self.assertTrue(selection.isChildSelected(x))
            self.assertEqual(1, selection.nSelectedChildren)

            sleep(config.SHORT_DELAY)

            # Deselecting does not deselects the item.
            selection.deselectSelectedChild(0)
            self.assertTrue(item.selected)
            self.assertTrue(selection.isChildSelected(x))

            # However, previous selection is not multiple,
            # previous item gets deselected
            if previous != None:
                self.assertFalse(previous.selected)

        if previous != None:
            self.assertFalse(previous.selected)

    def test_selection_events(self):
        listener = EventListener()
        datagridcell = self.rows_container.getChildAtIndex(2)
        selection = datagridcell._accessible.querySelection()

        # The item has 5 children:
        # - TableCell
        # - Cell0
        # - Cell1
        # - Cell2
        # - EmtpyCell
        # The first and the last are autogenerated cells,
        # don't represent our ItemsSource. Only the Cells implement SelectionItem
        for x in xrange(1, datagridcell.childCount - 1):
            item = datagridcell.getChildAtIndex(x)

            self.assertFalse(item.selected)
            self.assertFalse(selection.isChildSelected(x))

        # Let's select and unselect
        previous = None
        for x in xrange(1, datagridcell.childCount -1):
            item = datagridcell.getChildAtIndex(x)

            if previous != None:
                items = [ previous, item ]
            else:
                items = [ item ]

            with listener.listenTo(items):
                self.assertTrue(selection.selectChild(x))

                self.assertTrue(item.selected)
                if previous != None:
                    self.assertFalse(previous.selected)

            if previous != None:
                assert listener.containsEvent(previous, 'object:state-changed:selected', 1)
            assert listener.containsEvent(item, 'object:state-changed:selected', 1)

    # Action Tests

    def test_action(self):
        datagridcell = self.rows_container.getChildAtIndex(1)
        action = datagridcell._accessible.queryAction()

        self.assertEqual(1, action.nActions)
        self.assertEqual('click', action.getName(0))
        self.assertEqual('', action.getDescription(0))
        self.assertEqual('', action.getKeyBinding(0))

    def test_action_events(self):
        sleep(config.SHORT_DELAY)

        datagridcell = self.rows_container.getChildAtIndex(3)

        listener = EventListener()
        with listener.listenTo(datagridcell):
            datagridcell.click()

        assert listener.containsEvent(datagridcell, 'object:state-changed:selected', 1)

